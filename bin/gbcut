#!/usr/bin/perl -w
use FAST::Bio::SeqIO;
use FAST::Bio::AlignIO;
use FAST::Bio::UnivAln;
use FAST::Bio::SimpleAlign;
use FAST::Bio::Location::NarrowestCoordPolicy;
use Getopt::Std;
use vars qw($VERSION $DESC $tag);
$VERSION = 0.2;
$DESC    = "Extract subalignments based on reg-ex matching on features in an annotated genbank file.\n";

# PROCESS Command-line options:
$opt_h      = undef;
$opt_t      = undef;
$opt_i      = undef;
$opt_f      = 'fasta';
$opt_s      = undef;
$opt_v      = undef;
$opt_P      = undef;
$opt_x      = undef;
$opt_g      = undef;
$opt_n      = undef;
$opt_r      = undef; ## gap introns
$opt_C     = 0;
&getopts('hit:f:s:vP:x:gnC:');

$opt_h and do { 
    &print_help;
    die;
};

$tag = 'note';
$opt_t and $tag = $opt_t;

if (scalar(@ARGV) != 3) {
    die "Usage: $0 [options]  alignment-file genbank-file \'perl-reg-exp\' \nuse option -h for help.\n";
}

## PROCESS ARGUMENTS
$aln_file_nm = shift @ARGV;
$gb   = FAST::Bio::SeqIO->new(   -file =>  shift @ARGV , '-format' => 'genbank')->next_seq();
$aln  = FAST::Bio::UnivAln->new('-file' => $aln_file_nm);
$saln = FAST::Bio::AlignIO->new( -file =>  $aln_file_nm)->next_aln();
$rearg = shift @ARGV;
$re = ($opt_i ? qr/$rearg/i : qr/$rearg/);

die "Genbank sequence ID not found in alignment\n" unless ( $saln->each_seq_with_id($gb->id()) ); 

## PROCESS INTERSECTION RESTRICTION FEATURE ARG IF FOUND
if ($opt_x) {
  my $rearg = $opt_x;
  $rex = ($opt_i ? qr/$rearg/i : qr/$rearg/);
}

## SET POLICY TO NARROW
$narrow_policy = FAST::Bio::Location::NarrowestCoordPolicy->new();

## GET COLUMNS MATCHING FEATURE REGEX
foreach $feat ( $gb->top_SeqFeatures() ) {
  next if ($opt_P and $feat->primary_tag() ne $opt_P);
  $feat->location->coordinate_policy($narrow_policy);
  if ($feat->has_tag($tag)) {
    foreach $value ( $feat->each_tag_value($tag) ) {
      if ((!$opt_n and $value =~ $re) or ($opt_n and $value !~ $re)) {
	if ($opt_v) {
	  print STDERR "Matched ",$feat->primary_tag()," at ",$feat->location->to_FTstring()," with $tag $value.\n";
	}
	if (ref($feat->location) eq 'FAST::Bio::Location::Simple') {
	  my $start = $saln->column_from_residue_number($gb->id(),$feat->start);
	  my $stop  = $saln->column_from_residue_number($gb->id(),$feat->end);
	  push @colslice, ($start < $stop ? ($start-$opt_C)..($stop+$opt_C) : ($stop-$opt_C)..($start+$opt_C)); 
	}
	elsif (ref($feat->location) eq 'FAST::Bio::Location::Split') {
	  foreach my $subloc ($feat->location->sub_Location) {
	    my $start = $saln->column_from_residue_number($gb->id(),$subloc->start);
	    my $stop  = $saln->column_from_residue_number($gb->id(),$subloc->end);
	  push @colslice, ($start < $stop ? ($start-$opt_C)..($stop+$opt_C) : ($stop-$opt_C)..($start+$opt_C)); 
	  }
	}
      }
      ## GET COLUMNS MATCHING INTERSECTION REGEX IF EXISTS
      if ($opt_x and $value =~ $rex) {
	if (ref($feat->location) eq 'FAST::Bio::Location::Simple') {
	  my $start = $saln->column_from_residue_number($gb->id(),$feat->start);
	  my $stop  = $saln->column_from_residue_number($gb->id(),$feat->end);
	  push @x_colslice, ($start < $stop ? ($start-$opt_C)..($stop+$opt_C) : ($stop-$opt_C)..($start+$opt_C)); 
	}
	elsif (ref($feat->location) eq 'FAST::Bio::Location::Split') {
	  foreach my $subloc ($feat->sub_Location) {
	    my $start = $saln->column_from_residue_number($gb->id(),$subloc->start);
	    my $stop  = $saln->column_from_residue_number($gb->id(),$subloc->end);
	    push @x_colslice, ($start < $stop ? ($start-$opt_C)..($stop+$opt_C) : ($stop-$opt_C)..($start+$opt_C)); 
	  }
	}
      }
    }
  }
}

if ($opt_r) { ## match introns and gap them into alignment
  foreach $feat ( $gb->top_SeqFeatures() ) {
    next if ($opt_P and $feat->primary_tag() ne $opt_P);
    $feat->location->coordinate_policy($narrow_policy);
    if ($feat->has_tag($tag)) {
      foreach $value ( $feat->each_tag_value($tag) ) {
	if ($value =~ /intron/) {
	  if ($opt_v) {
	    print STDERR "Matched ",$feat->primary_tag()," at ",$feat->location->to_FTstring()," with $tag $value.\n";
	  }
	  my $start = $saln->column_from_residue_number($gb->id(),$feat->start);
	  my $stop  = $saln->column_from_residue_number($gb->id(),$feat->end);
	  ##	  push @intronslice, ($start < $stop ? ($start)..($stop) : ($stop)..($start)); 
	}
      }
    }
  }
  
  ## MAP INTRON TO GAP
  
}



## SORT AND COMPRESS THE COLUMN LIST
%seen = ();
@sc_colslice =  sort {$a <=> $b} grep { ! $seen{$_} ++ } @colslice;

if ($opt_x) {
  ## SORT AND COMPRESS THE INTERSECTION COL SLICE
  %seen = ();
  @x_sc_colslice = sort {$a <=> $b} grep { ! $seen{$_} ++ } @x_colslice;
  
  ## FIND THE INTERSECTION OF THE TWO LISTS
  %union = %isect = ();
  foreach (@sc_colslice, @x_sc_colslice) { $union{$_}++ && $isect{$_}++ }

  @sc_colslice = keys %isect;
}

## SUBSET AND PRINT ALIGNMENT
## SUBSET SEQUENCES IN ALIGNMENT IF DESIRED
if ($opt_s) {
  my $re = qr/$opt_s/;
  my @seqs = grep /$re/, @{ $aln->row_ids };
  my $seq_names = join ' ',@seqs; 
  $subaln = new FAST::Bio::UnivAln(-seqs=>scalar($aln->seqs({ids => $seq_names},\@sc_colslice)), -row_ids=>\@seqs);
}
else {
  $subaln = new FAST::Bio::UnivAln(-seqs=>scalar($aln->seqs([],\@sc_colslice)), -row_ids=>$aln->row_ids);
}

if ($opt_g) {
  $subaln = new FAST::Bio::UnivAln(-seqs=>scalar($subaln->no_allgap_sites()), -row_ids=>$subaln->row_ids);
}

$subaln->ffmt($opt_f); 
$layout = $subaln->layout();
## FIX FASTA PRINT BUG (IDs SHOULD GO RIGHT AFTER '>') 
if ($opt_f =~ /fasta/i) {
  $layout =~ s/^>\s+/>/gm;
}
print "$layout\n";


#-----------------------
sub print_help {
#-----------------------
    print STDERR << "QQ_HELP_QQ";
    
$0 version $VERSION
$DESC
Usage: $0 [-hi] [-t <tag>] 'alignment-file' 'genbank-file' 'perl-reg-exp'
 args: 1. alignment file in any format automatically supported by both 
           FAST::Bio::UnivAln::new and Bio::AlignIO::new (ie multifasta)
       2. genbank file with feature annotations to match. The identifier must match a sequence ID in the alignment file.
       3. perl-reg-ex, that is to say, the $re in '=~ /$re/'; protect reg-ex chars with quotes.
           example: 'exon 1' 
                    '(UTR|intron 1[357])'
                    'CDS'
                    'repeat \\w+'  
 opts: -h        this help 
       -i        case insensitive pattern matching (corresponds to m//i)
       -n        negate reg-ex match of main reg-ex (corresponds to  !~ m//) 
       -t <tag>  match genbank feature <tag>. 
                  Default is 'note.' 
                  Examples of alternatives: 'product', 'gene'
       -v        Verbose output, for example to see which features matched.
       -f <string> Output-format for subalignment. Default is fasta.
                   For alternatives, see 'layout' function of FAST::Bio::UnivAln.
       -s <perl-reg-ex> Only print slices from sequences in alignment with ids matching 
                        the option argument.  
       -x <perl-reg-ex> Only print slices that intersect with the features that match the 
                             option argument.
       -P <perl-reg-ex> Primary tag
       -g delete gap-only sites from the subalignment. 

input: from files.
outpt: alignment

This utility allows slicing of alignments by various criteria.
A requirement for it to work is that the id of the sequence in the genbank file 
is identical to an id of a sequence in the alignment file.
Slices are specified through perl-type regular-expression matching on both features
annotated in the genbank file and on sequence ids.

HOW IT WORKS
The program uses the FAST::Bio::SimpleAlign class to find the columns in the alignment 
that correspond to the features that are selected through reg-ex matching on
feature tags. The FAST::Bio::UnivAln class does the slicing. Both Simple (Bio::Location::Simple) 
  and Compound (FAST::Bio::Location::Split) features are supported, meaning that split features are
correctly processed so as to not include columns that do not really belong to the feature
(which is the bioperl default for feature algebra). 

WAYS TO SLICE
The union of all features that match the third argument are assembled by default, 
sorted by sequence order in the alignment.

An optional intersection argument allows further specification of alignment columns.
With this option, the result is all columns specified by the argument that overlap or
intersect with features specified by the argument to this option. An example usage
would be to.

The -n option allows subsetting of sequences by seq ids that match the supplied reg-ex.


Every feature in the genbank-file is 

    Do 'man perlre' for help on perl regular expressions.

        ## Print all subsequences from files ending in *.gb for features with '/product' =~ m/.+RNA/i 
    Ex: cat *.gb | $0 -it product '.+RNA' 

QQ_HELP_QQ
}











 





