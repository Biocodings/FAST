#!/usr/bin/perl -w
use POSIX;
use Getopt::Long qw(:config bundling require_order auto_version);
use Pod::Usage;
use FAST;
use FAST::Bio::SeqIO;
use FAST::Bio::Seq;
use strict;
use FAST::Bio::Tools::CodonTable;

use vars qw($VERSION $DESC $NAME $COMMAND $DATE);
$VERSION = $FAST::VERSION; 
$DESC    = "counts codon usage";
$NAME    = $0;
$NAME    =~ s/^.*\///;
$COMMAND = join " ",$NAME,@ARGV;
$DATE = POSIX::strftime("%c",localtime());

use constant { true => 1, false => 0 };

## DEFAULT OPTION VALUES
my $def_format  = $FAST::DEF_FORMAT;  #7/1/13 "fasta";
my $def_logname = $FAST::DEF_LOGNAME; #7/1/13 "FAST.log.txt";

## OPTION VARIABLES
my $man                  = undef;  # --man
my $help                 = undef;  # -h
my $moltype              = undef;  # -m, in case bioperl can't tell
my $format               = $def_format;  # --format
my $log                  = undef;        # -l
my $logname              = $def_logname; # -L
my $comment              = undef;        # -C
my $base_order           = undef; #-b
my $individual           = undef; #-v
my $suppress             = undef; #-s
my $amino_order          = undef; #-o
my $orderby_amino        = undef;
my $table                = 1; #-t 
my $append               = undef;
my $fastq                = undef;


GetOptions('help|h'         		 => \$help, 
	   'man'            		 => \$man,
	   'moltype|m=s'                 => sub{  my (undef,$val) = @_; 
						  die "$NAME: --moltype or -m option must be either \"dna\", \"rna\" or \"protein\"" 
						    unless $val =~ /dna|rna|protein/i; 
						  $moltype = $val;
						},
	   'format=s'                    => \$format,
	   'log|l'                       => \$log,
	   'logname|L=s'                 => \$logname,
	   'comment|C=s'                 => \$comment,
     'base-order|b=s'              => \$base_order,
     'individual|v'                => \$individual,
     'suppress|s'                  => \$suppress,
     'amino-order|o=s'             => \$amino_order,
     'order-by-amino|g'            => \$orderby_amino,
     'table|t=i'                   => \$table,
     'annotate|a'                    => \$append,
     'fastq|q'                     => \$fastq,
) 
or pod2usage(2);
		  
pod2usage(1) if $help;
pod2usage(-verbose => 2) if $man;
pod2usage("$0: Requires at least one argument (a fasta-file). Try $NAME -h for help.") if ((-t STDIN) && (@ARGV == 0));
pod2usage("$0: Expects no arguments when reading from STDIN. Try $NAME -h for help.") if (!(-t STDIN) && @ARGV != 0);

&FAST::log($logname, $DATE, $COMMAND, $comment) if ($log); 

if ($fastq) {
  $def_format = 'fastq'
}

my $code = FAST::Bio::Tools::CodonTable->new(-id => $table);
my @append_seqs;

my @bases;
if ($base_order) {
    die "-b option requires a base ordering of T,C,A, and G separated by colons (:), as in T:C:A:G (the default)\n" if ($base_order =~ /[^TCAG:]/);
    @bases = split /:/, $base_order;
}
else {
    @bases = qw/T C A G/;   
}

my %synonyms = ();
foreach my $aa (split //, "ARNDCQEGHILKMFPSTWYV*") {
    push @{ $synonyms{$aa}},  map {uc $_} $code->revtranslate($aa);
}

my %count = ();
my %startcount = (); ## start codons
my $middlecodons = my $startcodons = my $stopcodons = my $ambiguous_middle = my $ambiguous_start = my $ambiguous_stop = my $bad_length = my $numseqs = my $stop_at_middle = my $stop_at_start = my $nonstop = 0;


my $OUT = FAST::Bio::SeqIO->newFh('-format' => $def_format);
my $IN;

unless (@ARGV) {
    if ($moltype) {
	$IN = FAST::Bio::SeqIO->new(-fh => *STDIN{IO}, '-format' => $def_format, '-alphabet' => $moltype);
    }
    else {
	$IN = FAST::Bio::SeqIO->new(-fh => *STDIN{IO}, '-format' => $def_format);
    }
}

while ($IN or @ARGV) {
  if (@ARGV) {
    my $file = shift (@ARGV);
    unless (-e $file) {
      warn "$NAME: Could not find file $file. Skipping.\n";
      next;
    }
    elsif ($moltype) {
      $IN = FAST::Bio::SeqIO->new(-file => $file, '-format' => $def_format, '-alphabet' => $moltype);
    }
    else {
      $IN = FAST::Bio::SeqIO->new(-file => $file, '-format' => $def_format);
    }
  }
  if ($IN) { 
    while (my $seq = $IN->next_seq()) {
      if ($individual) {
        %count = ();
        %startcount = (); ## start codons
      }

      my $id=$seq->id();
      my $length = $seq->length(); ## is this slow?
      if ($length % 3) {
        warn "count_codons error_4: $id has length not of modulo 3, skipping this sequence.\n" unless ($suppress);
        $bad_length++;
      } 
      $numseqs++;
    
      my $seqseq = uc $seq->seq();
      ##    $seqseq =~ y/T/U/;
      my @bases = split//,$seqseq; 

      ## count start codons separately
      my $startcodon = join "",splice(@bases, 0, 3);
      my $aa = $code->translate($startcodon); 
      if ($aa eq "X") { ## ambiguous amino acid from ambiguous base, bioperl can resolve IUPAC codes
       $ambiguous_start++;
      }
      elsif ($aa eq "*") {
       warn "count_codons error_5: $id starts in a stop codon.\n" unless ($suppress);
       $stop_at_start++;
      }
      else { 
       $startcount{$startcodon}++;
       $startcodons++;
      }


    
      ## count stop codons together with others, but control them
      my $stopcodon = join "",splice(@bases, -3);
      $aa = $code->translate($stopcodon); 
      if ($aa eq "X") {
       $ambiguous_stop++ 
      }
      else {
       if ($aa ne "*") {
         warn "count_codons error_1: $id does not end in a stop codon, it ends in $stopcodon.\n" unless ($suppress);
         $nonstop++;
       }
       else {
        $stopcodons++
       }
       $middlecodons++;
       $count{$stopcodon}++; 
      }

    
     while (@bases) {
     my $codon = join "",splice(@bases, 0, 3);
     $aa = $code->translate($codon);
     if ($aa eq "X") {
       $ambiguous_middle++ 
      }
     elsif ($aa eq "*") {
       warn "count_codons error_2: $id has a premature stop codon.\n" unless ($suppress); 
       $stop_at_middle++;
       $count{$codon}++;
       $middlecodons++;
      }
      else { ## ambiguous amino acid from ambiguous base, bioperl can resolve IUPAC codes
       $count{$codon}++;
       $middlecodons++;
      }

      }
    if ($individual) {
     if (!$append){
     my $id = $seq->id . $seq->desc();
     &print_output($id);
     }
     else{
      my $old_desc = $seq->desc();
      my $new_desc = &print_output;
      $new_desc = "$old_desc $new_desc";
      $seq->desc($new_desc);
      print $OUT $seq;
     }
     }
    
    if ($append && !$individual){ #keep seq objects to append to later
      push (@append_seqs, $seq);
    }
  }
    undef $IN;
  }
}

unless ($individual) {
    if (!$append){&print_output;}
    else{
      my $desc_add = &print_output;
      my $old;
      my $desc_print;
      foreach my $print_seq (@append_seqs){
        $old = $print_seq->desc();
        $desc_print = "$old $desc_add";
        $print_seq->desc($desc_print);
        print $OUT $print_seq;
      }
    }
}
if (!$append){&print_end_totals;}


sub print_output {
    # calculate RCSU for middle codons
    my $append_count = 0;
    my $seq = $_[0];
    my $sum;
    my %rcsu = ();
    my %startrcsu = ();
    foreach my $aa (split //, "ARNDCQEGHILKMFPSTWYV*") {
     my @syns = @{$synonyms{$aa}};
     for (@syns) {
      $count{$_} ||= 0;
     }
  @rcsu{@syns} = @count{@syns};
  foreach my $syn (@syns) { 
      $sum += $rcsu{$syn};
  }
  $sum ||= 1;
  foreach my $syn (@syns) { 
      $rcsu{$syn} /= $sum;
  }
    }
    
    # calculate RCSU for start codons
    # only consider start codons actually seen
    %startrcsu  = %startcount;
    $sum = 0;
    foreach my $codon (keys %startrcsu) { 
  $sum += $startrcsu{$codon};
    }
    $sum ||= 1;
    foreach my $codon (keys %startrcsu) { 
  $startrcsu{$codon} /= $sum;
    }
    map {$sum+=$_} values %startrcsu;
    map {$_/$sum}  values %startrcsu;
    
    my $append_desc = "";
    
    if ($orderby_amino) { ## group output by amino acid
  if ($individual && !$append){print "$seq\n";}
  foreach my $aa (split //, ($amino_order || "ARNDCQEGHILKMFPSTWYV*")) {
      foreach my $codon (@{$synonyms{$aa}}) {
    $rcsu{$codon} ||= 0;
    $startrcsu{$codon} ||= 0;
    $count{$codon} ||= 0;
    $startcount{$codon} ||= 0;
    if (!$append){
    printf("%s %s %5.3f %5.3f %10u %10u\n",$code->translate($codon),$codon,$rcsu{$codon},$startrcsu{$codon},$count{$codon},$startcount{$codon});
    }
    else{ #append
      if ($append_count == 0){$append_desc .= sprintf("fascodon: %s %s %5.3f %5.3f %u %u|",$code->translate($codon),$codon,$rcsu{$codon},$startrcsu{$codon},$count{$codon},$startcount{$codon});}
      else {$append_desc .= sprintf("%s %s %5.3f %5.3f %u %u|",$code->translate($codon),$codon,$rcsu{$codon},$startrcsu{$codon},$count{$codon},$startcount{$codon});}    
      $append_count++;
    }
      }
    }
    if ($append){return $append_desc;}
    }
    else {
  if ($individual && !$append){print "$seq\n";}
  foreach my $first (@bases) { 
      foreach my $second (@bases) { 
    foreach my $third (@bases) { 
        my $codon = join "",$first,$second,$third;
        $rcsu{$codon} ||= 0;
        $startrcsu{$codon} ||= 0;
        $count{$codon} ||= 0;
        $startcount{$codon} ||= 0;
        if (!$append){
        printf("%s %s %5.3f %5.3f %10u %10u\n",$code->translate($codon),$codon,$rcsu{$codon},$startrcsu{$codon},$count{$codon},$startcount{$codon});
        }
        else{ #append
      if ($append_count == 0){$append_desc .= sprintf("fascodon: %s %s %5.3f %5.3f %u %u|",$code->translate($codon),$codon,$rcsu{$codon},$startrcsu{$codon},$count{$codon},$startcount{$codon});}
      else {$append_desc .= sprintf("%s %s %5.3f %5.3f %u %u|",$code->translate($codon),$codon,$rcsu{$codon},$startrcsu{$codon},$count{$codon},$startcount{$codon});}    
      $append_count++;
    }
    }
      }
  }
    if ($append){return $append_desc;}
    

}
}

sub print_end_totals {    
    printf "::--------------------------------------------------\n";
    printf ":1                %10u %10u            | unambiguous codons at tail (middle+end) and at start\n",$middlecodons,$startcodons;
    printf ":2                %10u %10u %10u | ambiguous   codons in middle, at start, and at end\n",$ambiguous_middle,$ambiguous_start,$ambiguous_stop;
    printf "::                                                 | (ambiguous codons are skipped)\n";
    printf ":3                %10u %10u            | stop        codons in middle and at start\n",$stop_at_middle,$stop_at_start;
    printf ":4                                      %10u | stop        codons at end (included in line 1)\n",$stopcodons;
    printf ":4                                      %10u | sense       codons at end (included in line 1)\n",$nonstop;
    printf "::--------------------------------------------------\n";
    printf ":5 %-10u of %-10lu sequences had a length non-modulo 3 and were skipped.\n",$bad_length,$numseqs;
}


__END__

=head1 NAME

fascodon - counts codon usage

=head1 SYNOPSIS

fascodon [options] [MULTIFASTA-FILE...]

=head1 DESCRIPTION

fascodon takes multifasta format sequence or alignment data as input, and
analyzes codon usage. Output can be for multifasta file or for individual
fasta files within a multifasta.

Options specific to fascodon:
  B<-b>, B<--base-order>
  B<-v>, B<--individual>                  option will print codon usage for 
                               	 individual fasta files
  B<-s>, B<--suppress>              option will supress error messages
  B<-o>, B<--amino-order>
  B<-g>, B<--order-by-amino>        option will order amino acid ouput in 
                                     alaphabetical order 
  B<-t>, B<--table>                 specifies which codon table to use
  B<-a>, B<--append>                option will append description with
                                     information of codon usage

Options general to FAST:
  -h, --help                  	 print a brief help message
  --man             	           print full documentation
  --version                         print version
  -l, --log                         create/append to logfile	
  -L, --logname=<string>            use logfile name <string>
  -C, --comment=<string>            save comment <string> to log
  --format=<format>                 use alternative format for input  
  --moltype=<[dna|rna|protein]>     specify input sequence type
  -q                                use a fastq file as input

=head1 INPUT AND OUTPUT

fascodon is part of FAST, the FAST Analysis of Sequences Toolbox, based
on Bioperl. Most core FAST utilities expect input and return output in
multifasta format. Input can occur in one or more files or on
STDIN. Output occurs to STDOUT. The FAST utility B<fasconvert> can
reformat other formats to and from multifasta.

=head1 OPTIONS

=over 8

=item B<-b>
      B<--base-order>

=item B<-v>
      B<--individual>

This option will take each fasta within a multifasta and print codon usage
seperated by the sequence identifiers

=item B<-s>
      B<--supress>

This option will supress any error messages or warnings, such as messages warning
about premature stop codons, sequences that do not end in stop codons or
sequences that are not divisible by 3.

=item B<-o>
      B<--amino-order>


=item B<-g>
      B<--order-by-amino>

This option will create an output of codon usages alphabetized by the 
amino acid associated with the codon

=item B<-t>
      B<--table>

This option allows you to pick which codon table to use for amino acid
assignment. Your choice is indicated by supplying the number associated
with the codon table.

=item B<-a>
      B<--append>

This option will append the description of each of the sequences, adding 
the codon usage information.

=item B<-h>,
      B<--help>

Print a brief help message and exit.

=item B<--man>

Print the manual page and exit.

=item B<--version>

Print version information and exit.

=item B<-l>,
      B<--log>

Creates, or appends to, a generic FAST logfile in the current working
directory. The logfile records date/time of execution, full command
with options and arguments, and an optional comment.

=item B<-L [string]>,
      B<--logname=[string]>

Use [string] as the name of the logfile. Default is "FAST.log.txt".

=item B<-C [string]>,
      B<--comment=[string]>

Include comment [string] in logfile. No comment is saved by default.

=item B<--format=[format]> 		  

Use alternative format for input. See man page for "fasconvert" for
allowed formats. This is for convenience; the FAST tools are designed
to exchange data in Fasta format, and "fasta" is the default format
for this tool.

=item B<-m [dna|rna|protein]>,
      B<--moltype=[dna|rna|protein]> 		  

Specify the type of sequence on input (should not be needed in most
cases, but sometimes Bioperl cannot guess and complains when
processing data).

=item B<-q>

Use a fastq file for input.

=back

=head1 EXAMPLES

Print all sequences with "-DNA" in the ID:

=over 8

cat data.fas | fasgrep "-DNA" > data.dna.fas

=back



=head1 SEE ALSO

=over 8

=item C<man perlre>

=item C<perldoc perlre>

Documentation on perl regular expressions.

=item C<man FAST>

=item C<perldoc FAST>

Introduction and cookbook for FAST

=item L<The FAST Home Page|http://compbio.ucmerced.edu/ardell/FAST>"

=back 

=head1 CITING

If you use FAST, please cite I<Lawrence et al. (2014). FAST: FAST Analysis of
Sequences Toolbox.> and Bioperl I<Stajich et al.>. 

=cut
