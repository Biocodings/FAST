#!/usr/bin/perl -w
use Getopt::Std;
use FAST::Bio::SeqIO;
use FAST::Bio::Tools::SeqPattern ();
use vars qw($VERSION $DESC);
$VERSION = 0.3;
$DESC    = "Transliterates, deletes, squeezes, and counts characters on IDs, sequences, or descriptions.\n";
$NAME    = $0;
$NAME    =~ s/^.*\///;

# Command-line options:
$opt_s      = undef;
$opt_d      = undef;
$opt_f      = 'fasta';
$opt_h      = undef;
$opt_C      = undef;
$opt_D      = undef;
$opt_S      = undef;
$opt_N      = undef;

&getopts('hsdf:CDSN');

if ($opt_h or scalar(@ARGV) < 2) {
  print STDERR <<"QQ_HELP_QQ";
 
  $NAME $VERSION
  $DESC
  Copyleft 2001-2009 David H. Ardell
  All wrongs reversed.

  Usage: $NAME [options] \'search-char-list\' \'replacement-char-list\' fasta-file1 fasta-file2 ... > fasta-file.
         $NAME [options] \'search-char-list\' \'replacement-char-list\' < fasta-file1 > fasta-file.

  Options: 
     -s match on sequence [default: match on ID]
     -d match on description [default: match on ID]
     -f <format> read <format> on input instead of default fasta. <format>
                 may be one of: embl,exp,fastq,gcg,genbank,pir,scf
                                ace,game,locuslink,phd,qual,raw,swiss
                 <format> is case-insensitive; google "FAST::Bio::SeqIO" for more info.
     -C complement search-char-list
     -D delete found but unreplaced characters
     -S squeeze duplicate replaced characters
     -N append the command and its number of characters replaced or deleted to the description

  In general, $NAME faciliates the application of a tr/// operator on
  all ids, descriptions or sequences on input.  This facilitates
  character remapping, case changes, deletions, degapping, squeezing
  of repeated characters, and more.  Counts of characters operated on
  are optionally reported in sequence descriptions with -N option.

  The task of masking out bad characters according to conventional
  sequence alphabets may be better done with fasstrict.

  search-char-list and replacement-character-list can include ranges
  such as 'a-z' and '0-9'. For other conventions please see perl
  documentation for the tr/// operator. $NAME does not accept all the
  same kinds of arguments as the 'tr' utility does; for example,
  arguments like '[:lower:]' will not be understood.

  Examples:

 
QQ_HELP_QQ
exit 1;
}

$search = shift @ARGV;
$replace = shift @ARGV;

$OUT = FAST::Bio::SeqIO->newFh('-format' => 'fasta');
unless (@ARGV) {
  $IN = FAST::Bio::SeqIO->new(-fh => *STDIN{IO}, '-format' => $opt_f);
}

$component = 'id';
$component = 'desc' if ($opt_d);
$component = 'seq'  if ($opt_s);

while ($IN or @ARGV) {
  if (@ARGV) {
    my $file = shift (@ARGV);
    unless (-e $file) {
      warn "Could not find file $file. Skipping.\n";
      next;
    }
    else {
      $IN = FAST::Bio::SeqIO->new(-file => $file, '-format' => $opt_f);
    }
  }
  if ($IN) { 
    while (my $seq = $IN->next_seq()) {
      my $matchfield = $seq->$component();
      my $count;
      my @options = ();
      push @options, 'c' if ($opt_C);
      push @options, 'd' if ($opt_D);
      push @options, 's' if ($opt_S);
      my $options = join '',@options;
      eval "\$count = \$matchfield =~ tr/$search/$replace/$options";
      $seq->$component($matchfield);
      if ($opt_N) {
	$seq->desc(join ' ',$seq->desc(),"fastr|$search|$replace|$options:$count");
      }
      print $OUT $seq;
    }
    undef $IN;
  }
}



