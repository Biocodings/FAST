#!/usr/bin/perl -w
use POSIX;
use Getopt::Long qw(:config bundling require_order auto_version);
use Pod::Usage;
use FAST;
use FAST::Bio::SeqIO;
use List::Gen qw/range/;
use strict;

use vars qw($VERSION $DESC $NAME $COMMAND $DATE);
$VERSION = $FAST::VERSION; 
$DESC    = "Select and reorder sequence record data based on index lists and ranges.\n";
$NAME    = $0;
$NAME    =~ s/^.*\///;
$COMMAND = join " ",$NAME,@ARGV;
$DATE = POSIX::strftime("%c",localtime());

use constant { true => 1, false => 0 };

## DEFAULT OPTION VALUES
my $def_format  = $FAST::DEF_FORMAT;  #7/1/13 "fasta";
my $def_logname = $FAST::DEF_LOGNAME; #7/1/13 "FAST.log.txt";
my $def_split_on_regex = ' ';
my $def_field_join     = " ";

## OPTION VARIABLES
my $man                  = undef;               # --man
my $help                 = undef;               # -h
my $moltype              = undef;               # -m, in case bioperl can't tell
my $log                  = undef;               # -l
my $logname              = $def_logname;        # -L
my $comment              = undef;               # -C
my $strict               = undef;               # --strict
my $identifier           = undef;               # -i
my $description          = undef;               # -d
my $field                = undef;               # -f
my $split_on_regex       = $def_split_on_regex; # -S 
my $field_join           = $def_field_join;     # -j
#my $spawn                = undef;               # -w

GetOptions('help|h'         		 => \$help, 
	   'man'            		 => \$man,
	   'moltype|m=s'                 => sub{  my (undef,$val) = @_; 
						  die "$NAME: --moltype or -m option must be either \"dna\", \"rna\" or \"protein\"" 
						    unless $val =~ /dna|rna|protein/i; 
						  $moltype = $val;
						},
	   'log|l'                       => \$log,
	   'logname|L=s'                 => \$logname,
	   'comment|C=s'                 => \$comment,
	   'strict'                      => \$strict,
	   'identifier|i'                => \$identifier,
	   'description|d'               => \$description,
	   'field|f'                     => \$field,
	   'split-on-regex|S=s'          => \$split_on_regex,
	   'join|j=s'                    => \$join,
#	   'spawn|w'                     => \$spawn,
	  ) 
  or exit(1);
		  
pod2usage(-verbose => 1) if $help;
pod2usage(-verbose => 2) if $man;
pod2usage("$NAME: expects one range-string argument and at least one input filename or glob. Try \"perldoc $NAME\"") if ((-t STDIN) && (@ARGV < 2));
pod2usage("$NAME: expects one range-string argument when input is on STDIN. Try \"perldoc $NAME\"") if ((!(-t STDIN)) && @ARGV != 1);

&FAST::log($logname, $DATE, $COMMAND, $comment) if ($log); 

##PARSE MULTICOORDS
my @RANGES = ();
my $ranges = shift @ARGV;
if ($ranges =~ /,/) {
    @RANGES = split (/,/,$ranges);
  }
else {
  $RANGES[0] = $ranges;
}
my @ranges = ();
foreach my $range (@RANGES) {
  my ($b,$e,$by);
  if ($range =~ /^([\d-]+)?(\.\.|:|-)([\d-]+)?(:([\d-]+))?$/) {
    if ($1) {
      $b = $1 + 0;
    }
    else {
      $b = 1;
    }
    if ($3) {
      $e = $3 + 0;
    }
    else {
      $e = -1;
    }
    if ($5) {
      $by = $5 + 0;
    }
    else {
      $by = undef;
    }
  }
  elsif ($range =~ /^([\d-]+)$/){
    $b = $1 + 0;
    $e = $b;
    $by = undef;
  }
  else {
    die "$NAME: Bad range \"$range\"\n";
  }
  push @ranges, [$b,$e,$by];
}

my ($selector,$type);
if ($identifier) {
  $selector = "id";
  $type = "identifier"
}
elsif ($description || $field) {
  $selector = "desc";
  $type = "description";
  $type .= " field" if ($field);
}
else {
  $selector = "seq";
  $type = "sequence";
}

my $split_re = qr/$split_on_regex/;


my $OUT = FAST::Bio::SeqIO->newFh('-format' => $def_format);
my $IN;
unless (@ARGV) {
    if ($moltype) {
  $IN = FAST::Bio::SeqIO->new(-fh => *STDIN{IO}, '-format' => $def_format, '-alphabet' => $moltype);
    }
    else {
  $IN = FAST::Bio::SeqIO->new(-fh => *STDIN{IO}, '-format' => $def_format);
    }
}

while ($IN or @ARGV) {
  if (@ARGV) {
    my $file = shift (@ARGV);
    unless (-e $file) {
      warn "$NAME: Could not find file $file. Skipping.\n";
      next;
    }
    elsif ($moltype) {
      $IN = FAST::Bio::SeqIO->new(-file => $file, '-format' => $def_format, '-alphabet' => $moltype);
    }
    else {
      $IN = FAST::Bio::SeqIO->new(-file => $file, '-format' => $def_format);
    }
  }
  if ($IN) { 
record: while (my $seq = $IN->next_seq()) {
      my $olddata = $seq->$selector();
      my $seqid = $seq->id(); # for error messages if necessary
      my $length; 
      my @olddata = ();
      if ($field) {
	@olddata = split $split_re,$olddata;
	$length = scalar @olddata;
      }
      else {
	@olddata = split //,$olddata;
	$length = length $olddata;      
      }
      my @newdata = ();
      my $newdata;
      my $newseq;
      foreach my $range (@ranges){
	if ($spawn) {
	  @newdata = ();
	}
	my ($b,$e,$by) = @$range;
	## interpret negative indices
	$b = ($b < 0 ? $length + $b + 1 : $b);
	$e = ($e < 0 ? $length + $e + 1 : $e);
	## check length bounds
	if ($strict) { ## strict; warns and skips sequence if indices are out of bounds,
	  if (!$by && $e < $b) {
	    warn "$NAME: Skipped sequence $seqid with $type length $length: bad range with end $e less than $b.\n";
	    next record;
	  }
	  if ($b < 1 or $e < 1 or $b > $length or $e > $length) {
	    warn "$NAME: Skipped sequence $seqid with $type length $length: indices $b and/or $e out-of-bounds.\n";
	    next record;
	  }
	}
	else {        ## otherwise, returns longest possible result within range
	  if (!$by && $e < $b) {
	    next;
	  }
	  if ($b < 1) {
	    $b = 1;
	  } 
	  elsif ($b > $length) {
	    next;
	  }
	  if ($e > $length) {
	   $e = $length;
	 } 
	  elsif ($e < 0) {
	    next;
	  }
	}
	$b -= 1;
	$e -= 1;
	my @slice = ();
	if ($b == $e) {
	  push @newdata,$olddata[$b];
	}
	elsif ($by) {
	  push @newdata,@olddata[@{ List::Gen::range ($b,$e,$by) }];
	}
	else {
	  push @newdata,@olddata[@{ List::Gen::range ($b,$e) }];
	}
      }
      ## if -sequence and no @newdata, don't print
      next if (!(scalar @newdata));
      $newdata = join (($field ? $join : ""),@newdata);
      if ($moltype) {
	$newseq = new FAST::Bio::Seq(-seq => $seq->seq,-id => $seq->id,-desc => $seq->desc, -alphabet => $moltype);
      }
      else {
	$newseq = new FAST::Bio::Seq(-seq => $seq->seq,-id => $seq->id,-desc => $seq->desc);
      }
      $newseq->$selector($newdata);
      print $OUT $newseq;
    }
    undef $IN;
  }
}


__END__

=head1 NAME

B<fascut> - select biosequence record data by character or field index

=head1 SYNOPSIS

B<fascut> [OPTION]... [RANGES] [MULTIFASTA-FILE]...

=head1 RANGE SPECIFICATION

        RANGES  : { RANGE | RANGE,RANGES }
         RANGE  : { INDEX | FROM>SEP<TO | FROM>SEP<TO:BY } 
         >SEP<  : {    ..     |       :       |       -      }
         INDEX  : nonzero integer
       FROM,TO  : nonzero integer or the empty string 
                   -- positive integers count from the first character or field         
                   -- negative integers count back from the last character or field
            BY  : a nonzero integer
                   -- positive integers step forward       
                   -- negative integers step backward

=head1 DESCRIPTION 

B<fascut> takes biological sequence records on input and outputs the
transformation of those records under index-based selection and
reordering of their sequence data (by default), identifiers or
descriptions. By default, B<fascut> cuts data per-character. For
sequence data, this utility outputs the concatenation of slices from
each sequence specified by a comma-separated list of coordinates and
coordinate ranges, allowing arbitrary reordering and repetition.

The one mandatory argument to B<fascut> is a sequence of indices or
index ranges separated by commas (,). The ranges may be specified in
Perl-style (or Genbank coordinate range-style) as in "from..to", in
R/Octave-style as in "from:to" or UNIX B<cut>-style as in
"from-to". If the index bounds of a simple range are missing, "from"
defaults to "1" and "to" defaults to "-1". An optional ":by" suffix
specifies an integer step-increment. 

B<One-based indexing> applies when B<fascut> cuts sequences (or
optionally identifiers or descriptions) by character (like B<cut
-c>). B<fascut -f> cuts descriptions by field, after the descriptions
are split by strings of white-space or user-defined regex. Field
indexing in B<fascut> is also one-based.

Negative indices count backwards from last characters and fields. If
the first range begins with a negative index, you will need to
terminate option processing with "--".  Ater converting negative
indices to positive indices for any given sequence on input, B<fascut>
expects every "from" index to be less than its respective "to" index
for every range unless a negative "by" parameter is given, in which
case "from" is expected to be greater than "to". If any of this is
violated for a given range and sequence, then that range will be
skipped for that sequence. If after conversions, "from" is negative,
it defaults to "1". If "to" is greather than a sequence length, it
defaults to "-1".  However, if strict-mode (-s) is enabled, then both
types of bad range specifications will abort processing of a sequence
record with no output for that sequence except a warning.

If "spawn-mode" (-w) is enabled, each range-input combination produces
a distinct sequence to output.

Options specific to fascut:
  -i, --identifier                 cuts identifiers by character
  -d, --description                cuts descriptions by character
  -f, --field                      cuts descriptions by field
  -S, --split-on-regex=<regex>     split description to fields using <regex>
  -j, --join=<string>              join selected field ranges using <string>
  -s, --strict                     strict range-checking; skips sequences with 
                                    warnings if ranges are out-of-bounds

Options general to FAST:
  -h, --help                  	    print a brief help message
  --man             	            print full documentation
  --version                         print version
  -l, --log                         create/append to logfile	
  -L, --logname=<string>            use logfile name <string>
  -C, --comment=<string>            save comment <string> to log
  --format=<format>                 use alternative format for input  
  --moltype=<[dna|rna|protein]>     specify input sequence type

=head1 INPUT AND OUTPUT

fascut is part of FAST, the FAST Analysis of Sequences Toolbox, based
on Bioperl. Most core FAST utilities expect input and return output in
multifasta format. Input can occur in one or more files or on
STDIN. Output occurs to STDOUT. The FAST utility B<fasconvert> can
reformat other formats to and from multifasta.

=head1 OPTIONS

=over 8

=item B<-a>
      B<--append>

This option will output each comma-separated range or position to a 
new sequence (stated in description)

=item B<-r string>
      B<--rename string>

This option will rename the id of the sequence with the string that you
provide.

=item B<-s>
      B<--strict>

This option will implement strict range checking on the coordinates. When
used this option will skip any sequences that the coordinates are out of
bounds on. (default is to give longest subsequence for that range)

=item B<-h>,
      B<--help>

Print a brief help message and exit.

=item B<--man>

Print the manual page and exit.

=item B<--version>

Print version information and exit.

=item B<-l>,
      B<--log>

Creates, or appends to, a generic FAST logfile in the current working
directory. The logfile records date/time of execution, full command
with options and arguments, and an optional comment.

=item B<-L [string]>,
      B<--logname=[string]>

Use [string] as the name of the logfile. Default is "FAST.log.txt".

=item B<-C [string]>,
      B<--comment=[string]>

Include comment [string] in logfile. No comment is saved by default.

=item B<--format=[format]> 		  

Use alternative format for input. See man page for "fasconvert" for
allowed formats. This is for convenience; the FAST tools are designed
to exchange data in Fasta format, and "fasta" is the default format
for this tool.

=item B<-m [dna|rna|protein]>,
      B<--moltype=[dna|rna|protein]> 		  

Specify the type of sequence on input (should not be needed in most
cases, but sometimes Bioperl cannot guess and complains when
processing data).

=back

=head1 EXAMPLES

Example 1:

=over 8

fascut 4 < in.fas > out.fas

=back

Example 2:

=over 8

fascut 1..8 < in.fas > out.fas

=back

Get all but the first 3 bases/aas:

=over 8

fascut 4..-1 < in.fas > out.fas

=back

Get the last 3 bases/aas:

=over 8

fascut -- -3..-1 < in.fas > out.fas

=back

Get the last 3 bases/aas to position 1000 if possible:

=over 8

fascut -- -3..1000 < in.fas > out.fas

=back

Example 3:

=over 8

fascut 1..4,2..6,-1 < in.fas > out.fas

=back

=head1 SEE ALSO

=over 8

=item C<man perlre>

=item C<perldoc perlre>

Documentation on perl regular expressions.

=item C<man FAST>

=item C<perldoc FAST>

Introduction and cookbook for FAST

=item L<The FAST Home Page|http://compbio.ucmerced.edu/ardell/FAST>"

=back 

=head1 CITING

If you use FAST, please cite I<Ardell (2013). FAST: FAST Analysis of
Sequences Toolbox. Bioinformatics> and Bioperl I<Stajich et al.>.

=cut


