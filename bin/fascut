#!/usr/bin/perl -w
use POSIX;
use Getopt::Long qw(:config bundling require_order auto_version);
use Pod::Usage;
use FAST;
use FAST::Bio::SeqIO;
use strict;

use vars qw($VERSION $DESC $NAME $COMMAND $DATE);
$VERSION = $FAST::VERSION; 
$DESC    = "Select subsequences based on coordinate lists and ranges.\n";
$NAME    = $0;
$NAME    =~ s/^.*\///;
$COMMAND = join " ",$NAME,@ARGV;
$DATE = POSIX::strftime("%c",localtime());

use constant { true => 1, false => 0 };

## DEFAULT OPTION VALUES
my $def_format  = $FAST::DEF_FORMAT;  #7/1/13 "fasta";
my $def_logname = $FAST::DEF_LOGNAME; #7/1/13 "FAST.log.txt";

## OPTION VARIABLES
my $man                  = undef;  # --man
my $help                 = undef;  # -h
my $moltype              = undef;  # -m, in case bioperl can't tell
my $log                  = undef;        # -l
my $logname              = $def_logname; # -L
my $comment              = undef;        # -C
my $rename               = undef;	 # -r
my $append               = undef;        # -a
my $strict               = undef;        # -s

my @COORDS = ();

GetOptions('help|h'         		 => \$help, 
	   'man'            		 => \$man,
	   'moltype|m=s'                 => sub{  my (undef,$val) = @_; 
						  die "$NAME: --moltype or -m option must be either \"dna\", \"rna\" or \"protein\"" 
						    unless $val =~ /dna|rna|protein/i; 
						  $moltype = $val;
						},
	   'log|l'                       => \$log,
	   'logname|L=s'                 => \$logname,
	   'comment|C=s'                 => \$comment,
	   'strict|s'                    => \$strict,
	   
	
	  ) 
  or exit(1);
		  
pod2usage(-verbose => 1) if $help;
pod2usage(-verbose => 2) if $man;
pod2usage("$NAME: Requires at least two arguments <coordinate> <fasta-file1> [fasta-file2...fasta-fileN]. Try $NAME -h for help.") if ((-t STDIN) && (@ARGV < 2));
pod2usage("$NAME: Requires one argument <coordinate> when reading from STDIN. Try $NAME -h for help.") if (!(-t STDIN) && @ARGV == 0);

&FAST::log($logname, $DATE, $COMMAND, $comment) if ($log); 

##PARSE MULTICOORDS
if ($ARGV[0] =~ /,/) {
    @COORDS = split (/,/,$ARGV[0]);
    shift (@ARGV);
  }
else {
  $COORDS[0] = shift (@ARGV);
}


my $OUT = FAST::Bio::SeqIO->newFh('-format' => $def_format);
my $IN;
unless (@ARGV) {
    if ($moltype) {
  $IN = FAST::Bio::SeqIO->new(-fh => *STDIN{IO}, '-format' => $def_format, '-alphabet' => $moltype);
    }
    else {
  $IN = FAST::Bio::SeqIO->new(-fh => *STDIN{IO}, '-format' => $def_format);
    }
}

while ($IN or @ARGV) {
  if (@ARGV) {
    my $file = shift (@ARGV);
    unless (-e $file) {
      warn "$NAME: Could not find file $file. Skipping.\n";
      next;
    }
    elsif ($moltype) {
      $IN = FAST::Bio::SeqIO->new(-file => $file, '-format' => $def_format, '-alphabet' => $moltype);
    }
    else {
      $IN = FAST::Bio::SeqIO->new(-file => $file, '-format' => $def_format);
    }
  }
  if ($IN) { 
sequence: while (my $seq = $IN->next_seq()) {
     my @seqs = ();
     my $seqlen = $seq->length;
     my $seqid  = $seq->id;  
     my $seqseq = '';
     my $subseq = undef;
     foreach my $coord (@COORDS) {
       my ($b,$e);
       if ($coord =~ /([\d-]+)\.\.([\d-]+)/) {
         $b = $1 + 0;
         $e = $2 + 0; 
       }
       else {
         $coord =~ /([\d-]+)/;
         $b = $1 + 0;
         $e = $b + 0;  
       }
       ## interpret negative coords
       $b = ($b < 0 ? $seqlen + $b + 1 : $b);
       $e = ($e < 0 ? $seqlen + $e + 1 : $e);
       ## check length bounds
       if ($strict) { ## strict; warns and skips sequence if coords are out of bounds,
	 if ($e < $b) {
	   warn "$NAME: Skipped sequence $seqid with length $seqlen: bad range with end $e less than $b.\n";
	   next sequence;
	 }
	 if ($b < 1 or $e < 1 or $b > $seqlen or $e > $seqlen) {
	   warn "Skipped sequence $seqid with length $seqlen: coord $coord out-of-bounds.\n";
	   next sequence;
	 }
       }
       else {        ## otherwise, returns longest possible non-null subsequence within range
	 if ($e < $b) {
	   next;
	 }
	 if ($b < 1) {
	   $b = 1;
	 } 
	 elsif ($b > $seqlen) {
	   next;
	 }
	 if ($e > $seqlen) {
	   $e = $seqlen;
	 } 
	 elsif ($e < 0) {
	   next;
	 }
       }
       push @seqs, $seq->subseq($b,$e);#$seqseq .= $seq->subseq($b,$e);
     }
     if (@seqs) {
       my $seqseq = join "",@seqs;
       if ($moltype) {
         $subseq = new FAST::Bio::Seq(-seq => $seqseq,-id => $seq->id,-desc => $seq->desc, -alphabet => $moltype);
       }
       else {
         $subseq = new FAST::Bio::Seq(-seq => $seqseq,-id => $seq->id,-desc => $seq->desc);
       }
       print $OUT $subseq;
     }
   }
    undef $IN;
  }
}


__END__

=head1 NAME

fascut - extract subsequences from fasta input by coordinate

=head1 SYNOPSIS

fascut COORDS [options] < fasta-file > fasta-file

=head1 DESCRIPTION

  COORDS: {POSITION|RANGE} | {POSITION|RANGE},COORDS
   RANGE: POSITION..POSITION with certain rules, see below
POSITION: nonzero integer 
              positive integers are sequence based (bioperl) position coordinates
              negative integers count from the end of each sequence starting with -1
              
              In a range "a..b" on a sequence of length L, the following rule must hold 
              for every sequence on input: 
                 a <= b or 
                 a <= (L - b + 1) or 
                 (L - a + 1) <= b or
                 (L - a + 1) <= (L - b + 1)  

           That is, after converting negative positions to positions from the end of the sequence, 
           the begin position must be less than the end position to be legal. If this rule is violated
           for a given range and sequence, that range will be skipped for that sequence. If strict-mode (-s) 
           is used, such a bad range specification will cause that sequence to be skipped entirely.

OUTPUT:
         * a range corresponds to the subsequence occuring from the begin to the end 
              positions __inclusively__
         * Comma-separated positions and ranges in the coordinate argument are arbitrary with
              respect to one another, e.g. they may overlap, be redundant, or be out of order.
              The result is not simplified or reduced.
         * Unless the strict option (-s) is used, the longest overlapping non-null subsequence
              will be chopped for each position or range (ie end-positions greater than the 
	      length of the sequence will reduce to the end of the sequence)
         * If the strict option is used, when any position or range in the coordinate argument 
              is out-of-bounds for a sequence, it will cause that sequence to be skipped 
              with a warning to standard error.
         * Unless the strict option (-s) is used, a coordinate argument resulting in a 
              a null sequence will cause that sequence to be silently skipped on output
         * If the coordinate argument begins with a negative POSITION or RANGE, precede 
             it with "--" to stop parsing the command-line for options 

Options specific to fascut:
  -a, --append                              output each comma-separated range or position
                                            to a new sequence (stated in description)
  -r <string>, --rename <string>            rename id of sequence to <string>
  -s, --strict                              strict range-checking on coords; skips a
                                            sequence with warning if coords are
                                            out-of-bounds on that sequence. 
                                            (default behavior is to give longest
                                            possible subsequence within range)

Options general to FAST:
  -h, --help                  	    print a brief help message
  --man             	            print full documentation
  --version                         print version
  -l, --log                         create/append to logfile	
  -L, --logname=<string>            use logfile name <string>
  -C, --comment=<string>            save comment <string> to log
  --format=<format>                 use alternative format for input  
  --moltype=<[dna|rna|protein]>     specify input sequence type

=head1 INPUT AND OUTPUT

fascut is part of FAST, the FAST Analysis of Sequences Toolbox, based
on Bioperl. Most core FAST utilities expect input and return output in
multifasta format. Input can occur in one or more files or on
STDIN. Output occurs to STDOUT. The FAST utility B<fasconvert> can
reformat other formats to and from multifasta.

=head1 OPTIONS

=over 8

=item B<-a>
      B<--append>

This option will output each comma-separated range or position to a 
new sequence (stated in description)

=item B<-r string>
      B<--rename string>

This option will rename the id of the sequence with the string that you
provide.

=item B<-s>
      B<--strict>

This option will implement strict range checking on the coordinates. When
used this option will skip any sequences that the coordinates are out of
bounds on. (default is to give longest subsequence for that range)

=item B<-h>,
      B<--help>

Print a brief help message and exit.

=item B<--man>

Print the manual page and exit.

=item B<--version>

Print version information and exit.

=item B<-l>,
      B<--log>

Creates, or appends to, a generic FAST logfile in the current working
directory. The logfile records date/time of execution, full command
with options and arguments, and an optional comment.

=item B<-L [string]>,
      B<--logname=[string]>

Use [string] as the name of the logfile. Default is "FAST.log.txt".

=item B<-C [string]>,
      B<--comment=[string]>

Include comment [string] in logfile. No comment is saved by default.

=item B<--format=[format]> 		  

Use alternative format for input. See man page for "fasconvert" for
allowed formats. This is for convenience; the FAST tools are designed
to exchange data in Fasta format, and "fasta" is the default format
for this tool.

=item B<-m [dna|rna|protein]>,
      B<--moltype=[dna|rna|protein]> 		  

Specify the type of sequence on input (should not be needed in most
cases, but sometimes Bioperl cannot guess and complains when
processing data).

=back

=head1 EXAMPLES

Example 1:

=over 8

fascut 4 < in.fas > out.fas

=back

Example 2:

=over 8

fascut 1..8 < in.fas > out.fas

=back

Get all but the first 3 bases/aas:

=over 8

fascut 4..-1 < in.fas > out.fas

=back

Get the last 3 bases/aas:

=over 8

fascut -- -3..-1 < in.fas > out.fas

=back

Get the last 3 bases/aas to position 1000 if possible:

=over 8

fascut -- -3..1000 < in.fas > out.fas

=back

Example 3:

=over 8

fascut 1..4,2..6,-1 < in.fas > out.fas

=back

=head1 SEE ALSO

=over 8

=item C<man perlre>

=item C<perldoc perlre>

Documentation on perl regular expressions.

=item C<man FAST>

=item C<perldoc FAST>

Introduction and cookbook for FAST

=item L<The FAST Home Page|http://compbio.ucmerced.edu/ardell/FAST>"

=back 

=head1 CITING

If you use FAST, please cite I<Ardell (2013). FAST: FAST Analysis of
Sequences Toolbox. Bioinformatics> and Bioperl I<Stajich et al.>.

=cut
