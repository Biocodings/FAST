#!/usr/bin/perl -w
use POSIX;
use Getopt::Long qw(:config bundling require_order auto_version);
use Pod::Usage;
use FAST;
use FAST::Bio::SeqIO;
use FAST::Bio::Tools::SeqPattern ();
use strict;

use vars qw($VERSION $DESC $NAME $COMMAND $DATE);
$VERSION = $FAST::VERSION; 
$DESC    = "Select sequences based on perl regular expression match on IDs, descriptions or sequences.\n";
$NAME    = $0;
$NAME    =~ s/^.*\///;
$COMMAND = join " ",$NAME,@ARGV;
$DATE = POSIX::strftime("%c",localtime());

use constant { true => 1, false => 0 };

## DEFAULT OPTION VALUES
my $def_format  = $FAST::DEF_FORMAT;  #7/1/13 "fasta";
my $def_logname = $FAST::DEF_LOGNAME; #7/1/13 "FAST.log.txt";

## OPTION VARIABLES
my $man                  = undef;  # --man
my $help                 = undef;  # -h
my $negate               = undef;  # -v
my $insensitive          = undef;  # -i
my $moltype              = undef;  # -m, in case bioperl can't tell

my $format               = $def_format;  # --format
my $log                  = undef;        # -l
my $logname              = $def_logname; # -L
my $comment              = undef;        # -C
my $split_on_regex       = undef;        # -S 

## in increasing priority:
my $match_description    = undef;  # -d
my $match_sequence       = undef;  # -s
my $match_field          = undef;  # -f

## in increasing priority:
my $iupac_ambiguity_expand_regex_prot        = undef; # -p, implies -s
my $iupac_ambiguity_expand_regex_nuc         = undef; # -e, implies -s
my $revcom_iupac_ambiguity_expand_regex_nuc  = undef; # -r, implies -s


GetOptions('help|h'         		 => \$help, 
	   'man'            		 => \$man,
	   'negate|v'                    => \$negate,
	   'case-insensitive|i'          => \$insensitive,
	   'moltype|m=s'                 => sub{  my (undef,$val) = @_; 
						  die "$NAME: --moltype or -m option must be either \"dna\", \"rna\" or \"protein\"" 
						    unless $val =~ /dna|rna|protein/i; 
						  $moltype = $val;
						},
	   'format=s'                    => \$format,
	   'log|l'                       => \$log,
	   'logname|L=s'                 => \$logname,
	   'comment|C=s'                 => \$comment,

	   'match-description|d'         => \$match_description,
	   'match-sequence|s'            => \$match_sequence,
	   'match-field|f=i'             => sub{  my (undef,$val) = @_; 
						  die "$NAME: --match-field or -f option takes a positive integer argument." 
						    unless $val != 0; 
						  $match_field = $val;
						},
	   'split-on-regex|S=s'          => \$split_on_regex,

           'iupac-expand-prot|p'         => \$iupac_ambiguity_expand_regex_prot,
	   'iupac-expand-nuc|e'          => \$iupac_ambiguity_expand_regex_nuc,
	   'revcom-iupac-expand-nuc|r'   => \$revcom_iupac_ambiguity_expand_regex_nuc,
	  ) 
  or pod2usage(2);
		  
pod2usage(1) if $help;
pod2usage(-verbose => 2) if $man;
pod2usage("$0: Requires exactly one argument (a regex) when taking input from STDIN. Try $NAME -h for help.") if ((-t STDIN) && (@ARGV != 1));
pod2usage("$0: Requires at least one argument. Try $NAME -h for help.") if (@ARGV == 0);

&FAST::log($logname, $DATE, $COMMAND, $comment) if ($log); 

my $arg = shift @ARGV;
my $re_string;

if ($iupac_ambiguity_expand_regex_nuc  and not $revcom_iupac_ambiguity_expand_regex_nuc) {
  $match_sequence = true;
  $re_string = new FAST::Bio::Tools::SeqPattern(-SEQ => $arg, -TYPE =>'Dna')->expand;
}
elsif ($revcom_iupac_ambiguity_expand_regex_nuc) {
  $match_sequence = true;
  $re_string = new FAST::Bio::Tools::SeqPattern(-SEQ => $arg, -TYPE =>'Dna')->revcom(1)->str;
}
elsif ($iupac_ambiguity_expand_regex_prot) {
  $match_sequence = true;
  $re_string = new FAST::Bio::Tools::SeqPattern(-SEQ => $arg, -TYPE =>'Protein')->expand;
}

else {
  $re_string = $arg;
}

my $re;
if ($insensitive) {
  $re = qr/$re_string/i;
}
else {
  $re = qr/$re_string/;
}

my $OUT = FAST::Bio::SeqIO->newFh('-format' => 'fasta');
my $IN;
unless (@ARGV) {
    if ($moltype) {
	$IN = FAST::Bio::SeqIO->new(-fh => *STDIN{IO}, '-format' => 'fasta', '-alphabet' => $moltype);
    }
    else {
	$IN = FAST::Bio::SeqIO->new(-fh => *STDIN{IO}, '-format' => 'fasta');
    }
}

while ($IN or @ARGV) {
  if (@ARGV) {
    my $file = shift (@ARGV);
    unless (-e $file) {
      warn "$NAME: Could not find file $file. Skipping.\n";
      next;
    }
    elsif ($moltype) {
      $IN = FAST::Bio::SeqIO->new(-file => $file, '-format' => 'fasta', '-alphabet' => $moltype);
    }
    else {
      $IN = FAST::Bio::SeqIO->new(-file => $file, '-format' => 'fasta');
    }
  }
  if ($IN) { 
    while (my $seq = $IN->next_seq()) {
      my $match_data = $seq->id();
      $match_data = $seq->desc() if ($match_description);
      $match_data = $seq->seq()  if ($match_sequence);
      ## This could be generalized so $match_field does not imply $match_description
      if ($match_field) {
	 my $desc = $seq->desc();
	 my @fields;
	 if ($split_on_regex) {
	   my $split_re = qr/$split_on_regex/;
	   @fields = split $split_re,$desc;
	   # @fields = split $split_re,$match_data;
	}
	else {
	  @fields = split ' ',$desc;
	  # @fields = split ' ',$match_data;
	}
	my $index;
	if ($match_field > 0) {
	  $index = $match_field - 1;
	}
	else { # $match_field < 0
	  $index = $match_field;
	}
	$match_data = $fields[$index];
      }
      print $OUT $seq if (((not $negate) and $match_data =~ $re) or ($negate and $match_data !~ $re));
    }
    undef $IN;
  }
}



__END__

=head1 NAME

fasgrep - print sequences matching a pattern

=head1 SYNOPSIS

fasgrep [options] \'PERL-REGEX\' [MULTIFASTA-FILE...]

=head1 DESCRIPTION

fasgrep takes multifasta format sequence or alignment data as input,
and outputs sequence records whose data match a perl regular
expression (regex) argument. By default, sequence identifiers are
queried by the regex. fasgrep takes one argument, a perl regular
expression. Regex arguments may require quoting to protect special
characters from interpretation by the shell.

Options specific to fasgrep:
  -s, --match-sequence              match on sequence 
  -d, --match-description           match on description 
  -f, --match-field=<int>           match field <int> in description
  -S, --split-on-regex=<regex>      use regex to split description
  -v, --negate                      output sequences that do not match
  -i, --insensitive                 match case-insensitively
  -e, --iupac-expand-nuc            expand ambiguities for DNA/RNA
  -r, --revcom-iupac-expand-nuc     reverse complement and expand 
  -p, --iupac-expand-prot           expand ambiguities for protein

Options general to FAST:
  -h, --help                  	 print a brief help message
  --man             	           print full documentation
  --version                         print version
  -l, --log                         create/append to logfile	
  -L, --logname=<string>            use logfile name <string>
  -C, --comment=<string>            save comment <string> to log
  --format=<format>                 use alternative format for input  
  --moltype=<[dna|rna|protein]>      specify input sequence type

=head1 INPUT AND OUTPUT

fasgrep is part of FAST, the FAST Analysis of Sequences Toolbox, based
on Bioperl. Most core FAST utilities expect input and return output in
multifasta format. Input can occur in one or more files or on
STDIN. Output occurs to STDOUT. The FAST utility B<fasconvert> can
reformat other formats to and from multifasta.

=head1 OPTIONS

=over 8

=item B<-s>,
      B<--match-sequence> 		

Query actual sequence data with the regex.
Default: [query identifiers]

=item B<-d>,
      B<--match-description> 		

Query sequence descriptions with regex. If both -s and -d options are
used, -s takes priority.  Default: [query identifiers]

=item B<-f [int]>,
      B<--match-field=[int]>     

Query a specific field in sequence descriptions with regex. With this
option, the description is split into fields using strings of white
space as field delimiters (the default Perl behavior for splitting
lines of data into fields).

This option takes a mandatory integer option argument giving the index
for which field the regex should query. One-based indexing is used, so
the first field after the identifier has index 1. As standard in Perl,
negative indices count backwards from the last field in the
description; field "-1" is the last field, "-2" is the second-to-last
etc.

In fasta files, the identifier occurs between the record separator
(">") and the first whitespace on the identifier line, and the
description is everything after the first string of white space on the
identifier line. Therefore the identifier is counted as the 0th field,
which is what fasgrep matches by default. 

This option takes priority over both -s and -d.

=item B<-S [regex]>,
      B<--split-on-regex=[regex]>   

Use regex <regex> to split the description for the -f option instead
of the perl default (which splits on one or more whitespace
characters). Special characters must be quoted to protect them from
the shell.

=item B<-v>,
      B<--negate> 	   

Output sequences that B<do not> match the regular expression argument.

=item B<-i>,
      B<--insensitive> 	   

Match data case-insensitively.

=item B<-e>,
      B<--iupac-expand-nuc> 	  

Expand IUPAC ambiguity symbols in the regex argument for DNA/RNA
sequence matching (implies -s, matching on sequence data). For
example, the symbol "B" in the regex is equivalent to "[CGTU]". This
option, -e, has priority over -p.

=item B<-r>,
      B<--revcom-iupac-expand-nuc> 	  

Reverse complement the regular-expression and expand IUPAC ambiguity
symbols for DNA/RNA sequence matching (implies -s, matching on
sequence data). For example, the symbol "B" in the regex is equivalent
to "[ACG]". This option, -r, takes priority over -e or -p.
priority.

=item B<-p>,
      B<--iupac-expand-prot> 	  

Expand IUPAC ambiguity symbols in the regex argyment for protein
sequence matching (implies -s, matching on sequence data).

=item B<-m [dna|rna|protein]>,
      B<--moltype=[dna|rna|protein]> 		  

Specify the type of sequence on input (should not be needed in most
cases, but sometimes Bioperl cannot guess and complains when
processing data).

=item B<-h>,
      B<--help>

Print a brief help message and exit.

=item B<--man>

Print the manual page and exit.

=item B<--version>

Print version information and exit.

=item B<-l>,
      B<--log>

Creates, or appends to, a generic FAST logfile in the current working
directory. The logfile records date/time of execution, full command
with options and arguments, and an optional comment.

=item B<-L [string]>,
      B<--logname=[string]>

Use [string] as the name of the logfile. Default is "FAST.log.txt".

=item B<-C [string]>,
      B<--comment=[string]>

Include comment [string] in logfile. No comment is saved by default.

=item B<--format=[format]> 		  

Use alternative format for input. See man page for "fasconvert" for
allowed formats. This is for convenience; the FAST tools are designed
to exchange data in Fasta format, and "fasta" is the default format
for this tool.


=back

=head1 EXAMPLES

Print all sequences with "-DNA" in the ID:

=over 8

cat data.fas | fasgrep "-DNA" > data.dna.fas

=back

Print all seqs with "mammal", "Mammal" or "MAMMAL" in the description:

=over 8

fasgrep -di "mammal" < data.fas > mammal.fas     

=back

Print all sequences with the motif MSDQ in them:

=over 8

fasgrep -s  "MSDQ"  < data.fas > MSDQ.fas       
    
=back

Print all sequences that don't start with S or R:
    
=over 8

fasgrep -v "^[SR]" < data.fas > sub.fas         

=back

Print all sequences matching purine-purine-pyrimidine:

=over 8

fasgrep -sem dna "RRY"  < data.fas > RRY.fas 
   
fasgrep -se "RRY"  < data.fas > RRY.fas        

fasgrep -s "[AG][AG][CT]" < data.fas > RRY.fas

fasgrep -s "[AG]{2}[CT]" < data.fas > RRY.fas

=back

=head1 SEE ALSO

=over 8

=item C<man perlre>

=item C<perldoc perlre>

Documentation on perl regular expressions.

=item C<man FAST>

=item C<perldoc FAST>

Introduction and cookbook for FAST

=item L<The FAST Home Page|http://compbio.ucmerced.edu/ardell/FAST>"

=back 

=head1 CITING

If you use FAST, please cite I<Ardell (2013). FAST: FAST Analysis of
Sequences Toolbox. Bioinformatics> and Bioperl I<Stajich et al.>.

=cut
