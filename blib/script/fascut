#!/Users/travislawrence/perl5/perlbrew/perls/perl-5.18.2/bin/perl -w 

eval 'exec /Users/travislawrence/perl5/perlbrew/perls/perl-5.18.2/bin/perl -w  -S $0 ${1+"$@"}'
    if 0; # not running under some shell
use Getopt::Std;
use FAST::Bio::SeqIO;
use vars qw($VERSION $DESC $opt_h $opt_f);
$VERSION = 0.1;
$DESC    = "Extract subsequences from fasta input by coordinate\n";
$NAME    = $0;
$NAME    =~ s/^.*\///;

# Command-line options:
$opt_f = 'fasta';
$opt_s = undef;
$opt_t = undef;
$opt_i = undef; ## id
$opt_m = undef; ## force moltype

&getopts('hsti:f:m:');

if ($opt_h or scalar(@ARGV) != 1) {
  print STDERR <<"QQ_HELP_QQ";
 
  $NAME $VERSION
  $DESC
  Copyleft 2001-2009 David H. Ardell
  All wrongs reversed.
  
  Usage  : $NAME COORDS < fasta-file > fasta-file
   COORDS: {POSITION|RANGE} | {POSITION|RANGE},COORDS
    RANGE: POSITION..POSITION with certain rules, see below
 POSITION: nonzero integer 
              positive integers are sequence based (bioperl) position coordinates
              negative integers count from the end of each sequence starting with -1
              
              In a range "a..b" on a sequence of length L, the following rule must hold 
              for every sequence on input: 
                 a <= b or 
                 a <= (L - b + 1) or 
                 (L - a + 1) <= b or
                 (L - a + 1) <= (L - b + 1)  

           That is, after converting negative positions to positions from the end of the sequence, 
           the begin position must be less than the end position to be legal. If this rule is violated
           for a given range and sequence, that range will be skipped for that sequence. If strict-mode (-s) 
           is used, such a bad range specification will cause that sequence to be skipped entirely.
    
  OUTPUT: 
         * a range corresponds to the subsequence occuring from the begin to the end 
              positions __inclusively__
         * Comma-separated positions and ranges in the coordinate argument are arbitrary with
              respect to one another, e.g. they may overlap, be redundant, or be out of order.
              The result is not simplified or reduced.
         * Unless the (-m) option is used, for each sequence in the input, 
              the subsequences specified by every 
              position or range are concatenated in the order of the coordinate argument 
              and, if the result is non-empty, output with the same id and description
         * Unless the strict option (-s) is used, the longest overlapping non-null subsequence
              will be chopped for each position or range (ie end-positions greater than the 
	      length of the sequence will reduce to the end of the sequence)
         * If the strict option is used, when any position or range in the coordinate argument 
              is out-of-bounds for a sequence, it will cause that sequence to be skipped 
              with a warning to standard error.
         * Unless the strict option (-s) is used, a coordinate argument resulting in a 
              a null sequence will cause that sequence to be silently skipped on output
         * If the coordinate argument begins with a negative POSITION or RANGE, precede 
             it with "--" to stop parsing the command-line for options 

  Examples: $NAME 4   < in.fas > out.fas
            $NAME 1..8 < in.fas > out.fas
            $NAME 4..-1 < in.fas > out.fas ## all but the first 3 bases/aas
            $NAME -- -3..-1 < in.fas > out.fas ## the last 3 bases/aas
            $NAME -- -3..1000 < in.fas > out.fas ## the last 3 bases/aas to position 1000 if possible
      	    $NAME 1..4,2..6,-1 < in.fas > out.fas

            
   Options: -h print this help
            -f <format> read <format> on input instead of default fasta.
               <format> may be one of: embl,exp,fastq,gcg,genbank,pir,scf
                                       ace,game,locuslink,phd,qual,raw,swiss
               <format> is case-insensitive; google "FAST::Bio::SeqIO" for more info.
            -s strict range-checking on coords; skips a sequence with warning if coords are out-of-bounds 
                 on that sequence. 
                 (default behavior is to give longest possible subsequence within range)
            -t output each comma-separated range or position to a new sequence (stated in description).
            -i <string> rename id of sequence to <string>
            -m <moltype> (one of protein,rna,dna) force moltype/alphabet of input sequences 
                         (for when Bioperl can't guess it right or at all)

    
QQ_HELP_QQ
exit 1;
}

##PARSE MULTICOORDS
if ($ARGV[0] =~ /,/) {
    @COORDS = split /,/,$ARGV[0];
  }
else {
  $COORDS[0] = $ARGV[0];
}

if ($opt_m) {
  $IN = FAST::Bio::SeqIO->new(-fh => *STDIN{IO}, '-format' => $opt_f, '-alphabet' => $opt_m);
}
else {
  $IN = FAST::Bio::SeqIO->new(-fh => *STDIN{IO}, '-format' => $opt_f);
}
$OUT = FAST::Bio::SeqIO->newFh('-format' => $opt_f);
sequence: while (my $seq = $IN->next_seq()) {
  my @seqs = ();
    my $seqlen = $seq->length;
    my $seqid  = $seq->id;  
    my $seqseq = '';
    foreach my $coord (@COORDS) {
	my ($b,$e);
	if ($coord =~ /([\d-]+)\.\.([\d-]+)/) {
	    $b = $1;
	    $e = $2;	
	}
	else {
	    $coord =~ /([\d-]+)/;
	    $b = $1;
	    $e = $b;	
	}
	## interpret negative coords
	$b = ($b < 0 ? $seqlen + $b + 1 : $b);
	$e = ($e < 0 ? $seqlen + $e + 1 : $e);
	## check length bounds
	if ($opt_s) { ## strict; warns and skips sequence if coords are out of bounds,
	    if ($e < $b) {
		warn "Skipped sequence $seqid with length $seqlen: bad range with end $e less than $b.\n";
		next sequence;
	    }
	    if ($b < 1 or $e < 1 or $b > $seqlen or $e > $seqlen) {
		warn "Skipped sequence $seqid with length $seqlen: coord $coord out-of-bounds.\n";
		next sequence;
	    }
	}
	else {        ## otherwise, returns longest possible non-null subsequence within range
	    if ($e < $b) {
		next;
	    }
	    if ($b < 1) {
		$b = 1;
	    }	
	    elsif ($b > $seqlen) {
		next;
	    }
	    if ($e > $seqlen) {
		$e = $seqlen;
	    } 
	    elsif ($e < 0) {
		next;
	    }
	}
	if ($opt_t) {
	    my $trunc = $seq->trunc($b,$e);
	    $trunc->display_id($opt_i || $seq->id);
	    $trunc->desc(join "-",$seq->desc,"$b..$e");
	    print $OUT $trunc;
	}
	else {
	  push @seqs, $seq->subseq($b,$e);#	    $seqseq .= $seq->subseq($b,$e);
	}
    }
    unless ($opt_t or not @seqs) {
      my $seqseq = join "",@seqs;
      if ($opt_m) {
	$subseq = new FAST::Bio::Seq(-seq => $seqseq,-id => ($opt_i || $seq->id),-desc => $seq->desc, -alphabet => $opt_m);
      }
      else {
	$subseq = new FAST::Bio::Seq(-seq => $seqseq,-id => ($opt_i || $seq->id),-desc => $seq->desc);
      }
      print $OUT $subseq;
    }
}















