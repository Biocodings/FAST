#!/usr/bin/perl -w

eval 'exec /usr/bin/perl -w -S $0 ${1+"$@"}'
    if 0; # not running under some shell
use FAST::Bio::SeqIO;
use Getopt::Std;
use Carp;
use vars qw($VERSION $DESC $NAME $USAGE $tag);
$VERSION = 0.3;
$DESC    = "Extract subsequences for potentially split features from GenBank file(s) with tag-based filtering.\n";
$NAME    = $0;
$NAME    =~ s/^.*\///;
$USAGE   = "Usage: $NAME -[hil] [-P Primary-tag-perl-regex] [-t <tag1>[=^]<perl-regex1>+<tag2>[=^]<perl-regex2>+...] < genbank-file";

# PORTIONS OF THIS SCRIPT WERE CRIBBED FROM bp_extract_feature_seq.pl BY JASON STAJICH

# Command-line options:
$opt_h      = undef; ## help
$opt_t      = undef; ## regex match on tag (an attribute of a feature) 
$opt_P      = undef; ## match primary tag
$opt_i      = undef; ## case-insensitive
$opt_C      = 0; ## CONTEXT
$opt_l      = undef;
&getopts('hit:C:P:l');

$opt_h and do { 
    &print_help;
    die;
};

if (scalar(@ARGV) != 0) {
    die "$USAGE\nuse option -h for help.\n";
}


if ($opt_t) { 
  foreach my $tvp (split /\+/,$opt_t) {
    unless ($tvp =~ /[=\^]/) {
      carp "Bad format in -t option";
      &print_help;
      die;
    }
    my ($tag,$op,$tag_regex) = split /([=\^])/,$tvp;
    unless ($tag and $op and $tag_regex) {
      carp "Bad format in -t option";
      &print_help;
      die;
    }
    push @tag,$tag; 
    push @op,($op eq "=" ? 1 : 0);
    push @tag_regex,($opt_i ? qr/$tag_regex/i : qr/$tag_regex/);
  }
}

$IN = FAST::Bio::SeqIO->new(-fh => *STDIN{IO}, '-format' => 'genbank');
$OUT = FAST::Bio::SeqIO->newFh('-format' => 'fasta');

while (my $seqobj = $IN->next_seq()) {
 FEAT: foreach my $feat ( $opt_P ? 
		     (grep { $_->primary_tag =~ /$opt_P/i } $seqobj->get_SeqFeatures() ) :
		     ($seqobj->get_SeqFeatures())
		   )  {
    foreach my $i (0..$#tag) {
      next FEAT unless (
		   (
		    ($feat->has_tag($tag[$i]) and $op[$i] and grep {/$tag_regex[$i]/} $feat->get_tag_values($tag[$i]))
		    or
		    ($feat->has_tag($tag[$i]) and not $op[$i] and not grep {/$tag_regex[$i]/} $feat->get_tag_values($tag[$i]))
		   )
		  );
    }
    my $loc_string  = $feat->location->to_FTstring;
    $loc_string =~ s/omplement//;
 
    ## HANDLE CONTEXT
    if ($opt_C != 0  and $feat->start > $feat->end) {
      $feat->start($feat->start + $opt_C);
      $feat->end  ($feat->end   - $opt_C);
    }
    elsif ($opt_C != 0) {
      $feat->start($feat->start - $opt_C);
      $feat->end  ($feat->end   + $opt_C);
    }

    $featseq = $feat->spliced_seq;

    ## SET DISPLAY ID TO RETURN ALL TAG INFORMATION; THIS CAN BE OPTIONALLY RESTRICTED
    $id = join "_", grep {/geneid/i} $feat->get_tagset_values($feat->get_all_tags());
    $id ||= join "_", grep {/gi/i} $feat->get_tagset_values($feat->get_all_tags());
    $id ||= join "_", $feat->get_tagset_values("gene");
    $id ||= join "_", $feat->get_tagset_values("product");
    $id ||= $loc_string;
    $featseq->display_id($id);
    $featseq->desc(join " ",(map {join "=",$_,(join "","\"",(join ";",grep {!/geneid/i} $feat->get_tagset_values($_)),"\"")} $feat->get_all_tags()),($opt_l ? "location=\"$loc_string\"" : '')); 
    
    print $OUT $featseq;
  }
}

#-----------------------
sub print_help {
#-----------------------
    print STDERR << "QQ_HELP_QQ";

$NAME $VERSION
$DESC
$USAGE
Optns: -h                           this help 
       -P <primary-tag-perl-regex>  filter only features with primary tags matching given perl-regex. Ex: 'CDS', 'RNA', 'CDS|RNA'
                                    (this regex is always matched case-insensitively)

       -t <tag1>[=^]<perl-regex1>+<tag2>[=^]<perl-regex2>  
                                   
                                    filter only features that have all specified tags: tag1, tag2, etc 
                                    and, for each tag, at least one value that either matches (=) or no value that matches (^)
                                    their specific perl-regexes: perl-regex1, perl-regex2, etc.
                                    Examples of tags: 'product', 'note', 'gene', 'db_xref'
                                    
       -i                           case-insensitive pattern matching for tag-value regexes with -t option (corresponds to m//i)
       -l                           print genomic location strings in the sequence descriptions
       ## NOT IMPLEMENTED: -C <int>                     take C bases of genomic sequence context to each feature-specified sequence
Input: from <stdin>
Outpt: multifasta file with sequences corresponding to specified features extracted by location from GenBank files
       sequence ids are set to GeneIDs if available, otherwise GI numbers if available, otherwise gene names if available, otherwise 
       product names if available, otherwise the location string. 
       sequence descriptions preserve as much information from the feature table as possible

       Do 'man perlre' for help on perl regular expressions.

Exmpl: ## Print all CDSs 
       cat *.gb | $NAME -P CDS 

       ## Print all tRNAs with location strings 
       cat *.gb | $NAME -lP tRNA

       ## Print all CDSs with gene IDs starting with "100" and non-hypothetical products 
       cat *.gb | $NAME -P CDS -it db_xref=geneid:100+product^hypothetical

       ## Print sequences for all annotated features
       cat *.gb | $NAME

QQ_HELP_QQ
}

## TODO:
## revise all FAST scripts accordingly with eg $USAGE
## add coordinate policy and warning
## fix context









