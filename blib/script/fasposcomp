#!/Users/travislawrence/perl5/perlbrew/perls/perl-5.18.2/bin/perl -w

eval 'exec /Users/travislawrence/perl5/perlbrew/perls/perl-5.18.2/bin/perl -w -S $0 ${1+"$@"}'
    if 0; # not running under some shell
use Getopt::Std;
use FAST::Bio::SeqIO;
use FAST::Bio::PrimarySeq;
use FAST::Bio::Tools::MySeqStats;
use Carp;
use vars qw($VERSION $DESC $dnastrict $dnaiupac $rnastrict $rnaiupac $proteinstrict $proteiniupac);
$VERSION = 1.0;
$DESC    = "Outputs monomer (letter) composition of a sequence in frames of variable length";

$opt_h      = undef; #help
$opt_f    = 'fasta'; #format
$opt_t      = undef; #total
$opt_p      = undef; #pipe
$opt_n      = undef; #normalize by total
$opt_s      = undef; #strict
$opt_i      = undef; #iupac
$opt_m      = undef; #moltype
$opt_c      = undef; #ignore case
&getopts('hf:tpsm:cin');
$opt_h and do { 
    &print_help;
    die;
};
$opt_m and do { 
  die "USAGE: $0 -m [dna|rna|protein]\n" if ('dna protein rna' !~ /$opt_m/);
};
$opt_s and do { 
  $opt_i = undef;
  $opt_s = 'strict';
};
$opt_i and do { 
  $opt_s = 'iupac';
};
$opt_p and do {
  if (scalar(@ARGV) != 1) {
    die "-p, meaning pipe, implies only one argument (number of positions).\n";
  }
};

(!$opt_p) and do {
  if (scalar(@ARGV) == 0) {
    die "Wrong # of arguments. -p implies input from stdin if that's what you want.\n";
  }
};


## TO GO INTO DICTIONARY
local $dnastrict     = qr/[ACTGactg]/;
local $dnaiupac      = qr/[ACTGactgMRWSYKVHDBXNmrwsykvhdbxn]/;
local $rnastrict     = qr/[ACUGacug]/;
local $rnaiupac      = qr/[ACUGacugMRWSYKVHDBXNmrwsykvhdbxn]/;
local $proteinstrict = qr/[ACDEFGHIKLMNPQRSTVWYacdefghiklmnpqrstvwy]/;
local $proteiniupac  = qr/[ACDEFGHIKLMNPQRSTVWYacdefghiklmnpqrstvwyBZX\.bzx\*]/;
# USAGE $alphabet = $opt_m . $opt_s; $re = $$alphabet;

$numpos = shift @ARGV;

if ($opt_p) {
  $IN  = FAST::Bio::SeqIO->newFh('-format' => $opt_f);
  while(<$IN>) {
    my $seqobj = $_;
    process ($seqobj);
  }
  $opt_t and do {
    for $i (0..($numpos-1)) {
      &print_pos($i,$$sum[$i],'',$filter);
    }
  }
}
else {
  @seqfiles = glob($ARGV[0]);
  foreach $seqfilenm (@seqfiles) {
    my $sum= [];
    $IN  = FAST::Bio::SeqIO->new('-format' => $opt_f, -file => $seqfilenm);
    while(my $seqobj = $IN->next_seq) {
      process ($seqobj,$sum);  ## SUM IS LOCAL TO EACH FILE
    }
    $opt_t and do {
      for $i (0..($numpos-1)) {
	&print_pos($i,$$sum[$i],'',$filter);
      }
    }
  }
}
1;

#-----------------------
sub print_pos {
#-----------------------
  my ($pos,$hashref,$id,$filter) = @_;
  my ($normalizer,@keys);

  if ($opt_s) {
    foreach $key (keys %$hashref) {
      if ($key !~ $filter) {
	warn "Sequence", ($id ? " $id" : '(s)'), " contained excluded character \'$key\'.\n";
      }
    }
    unless ($opt_c) {$filter =~ tr/a-z\\//d;}
    $filter =~ /\[(.+)\]/; ## REGEXP A REGEXP
    $allowed = $1;
    @keys = split //,$allowed;
  } else {
    @keys = sort keys %$hashref;
  }
  print '> ';
  foreach $key (@keys) {
    printf ("%8s",$key);
  }
  print " TOTAL";
  if ($numpos == 1) {print " // $id\n  ";}
  else {print " // $id-(POS $pos)\n  ";} ## THE TRAILING SPACES PRIME FOR THE NEXT LINE
  if ($opt_n) {
    foreach $key (@keys) {
      $normalizer += (exists $$hashref{$key} ? $$hashref{$key} : 0);
    }
    foreach $key (@keys) {
      printf "%8.3f", ((exists $$hashref{$key} and $normalizer != 0) ? ($$hashref{$key}/$normalizer) : 0);
    }
  } else {
    foreach $key (@keys) {
      $normalizer += (exists $$hashref{$key} ? $$hashref{$key} : 0);
      printf "%8d", (exists $$hashref{$key} ? $$hashref{$key} : 0);
    }
      printf "%8d", $normalizer;
  }
  print "\n";
}
#-----------------------
sub process {
#-----------------------
  my $seqobj = shift;
  if (@_) {
    my $sum  = shift;
  } ## OTHERWISE GLOBAL
  
  $opt_m and do {
    $seqobj->moltype($opt_m); ##SET MOLTYPE OF ALL SEQUENCES
  };
  unless ($warned) {
    $job_moltype and do {
      if ($seqobj->moltype ne $job_moltype) {
	warn "Sequences appear not to be of the same type.\n";
      }
      $warned = 1;
    };
  }
  unless ($job_moltype) {
    $job_moltype = $seqobj->moltype;
  }
  if ($opt_c) {
    $primseq = $seqobj->primary_seq;
  } else {
    $primseq = FAST::Bio::PrimarySeq->new(uc $seqobj->seq);
  }
  ## HERE WE FACTOR THE SEQUENCE INTO CUTS BY POSITION
  my @bits = split //,$primseq->seq;
  my @cuts = ();
  my @primseqs = ();
  if (@bits % $numpos > 0) {
    carp "Sequence length ", ($#bits+1)," is not an even multiple of the chunk-size $numpos that you requested...\nProceeding anyway...\n";
  }
  for ($i = 0; $i < @bits; $i++) {
    push @{ $cuts[($i % $numpos)] }, $bits[$i];
  }
  for ($i = 0; $i < $numpos; $i++) {
    $primseqs[$i] = FAST::Bio::PrimarySeq->new(join '',@{ $cuts[$i] });
  }
  $filter = qr/./; ## MATCH ANY CHARACTER
  $opt_s and do {
    $alphabet = ($seqobj->moltype . $opt_s); 
    $filter = $$alphabet;
  };
  for $i (0..$#primseqs) {
    my $primseq = $primseqs[$i]; 
    my $seqstats = FAST::Bio::Tools::MySeqStats->new($primseq);
    $hash_ref = $seqstats->count_monomers();
    if ($opt_t) {
      foreach $mono (keys %$hash_ref) {
	$$$sum[$i]{$mono} += $$hash_ref{$mono};
      }
    } else {
      &print_pos($i,$hash_ref,$seqobj->display_id,$filter);
    }
  }
}



#-----------------------
sub print_help {
#-----------------------
    print STDERR << "QQ_HELP_QQ";
    
$0 version $VERSION
$DESC
Usage: $0 [-htpisc] [-m moltype] [-f <file-format>] < <seq-file>
   or: cat <seq-files> | $0 [-htpisc] [-m moltype] [-f <file-format>] 
 opts: -h this help 
       -t total composition over all sequences
       -p argument from stdin (else default is analyze a list of files as args)
       -n normalize (probabilities instead of frequencies)
       -f file format (default is fasta). Options are:

                       Fasta       FASTA format
                       EMBL        EMBL format
                       GenBank     GenBank format
                       swiss       Swissprot format
                       SCF         SCF tracefile format
                       PIR         Protein Information Resource format
                       GCG         GCG format
                       raw         Raw format (one sequence per line, no ID)
                       ace         ACeDB sequence format
			 
			 various case-spellings are allowed
       
       -s strict alphabet (only unambiguous sense monomers counted)
       -i iupac  alphabet (ambiguity and stop codes counted, -s overrides)
       -m force moltype [dna,rna,protein] (only affects behavior with a -s flag)
       -c count cases separately

 note: without -s or -i, any character is counted.  Columns may not represent the same 
       characters for multiple sequences if they don't have identical alphabets.
 args: at least one, the length of frame over which to count base frequencies.

 The behavior of -t (sum composition over sequences) depends on whether -p is selected
 or not. Without -p, each file in an argument list is totalled separately. With -p, all
 sequences in the stream (which may consist of separate files) are totaled.

QQ_HELP_QQ
}











