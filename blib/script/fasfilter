#!/Users/travislawrence/perl5/perlbrew/perls/perl-5.18.2/bin/perl -w 

eval 'exec /Users/travislawrence/perl5/perlbrew/perls/perl-5.18.2/bin/perl -w  -S $0 ${1+"$@"}'
    if 0; # not running under some shell
use Getopt::Std;
use FAST::Bio::SeqIO;
use vars qw($VERSION $DESC $opt_h $opt_f);
$VERSION = 0.1;
$DESC    = "Filter sequences in a fasta file by length.\n";
$NAME    = $0;
$NAME    =~ s/^.*\///;

# Command-line options:
$opt_f = 'fasta';

&getopts('hf:');

if ($opt_h or scalar(@ARGV) != 1) {
  print STDERR <<"QQ_HELP_QQ";

  $NAME $VERSION
  $DESC
  Copyleft 2001-2009 David H. Ardell
  All wrongs reversed.
  
  Usage   : $NAME SPECTRUM < fasta-file > fasta-file
 SPECTRUM : BAND | BAND,SPECTRUM
     BAND : { LOWER_BOUND.. | LOWER_BOUND..UPPER_BOUND}
    BOUND : positive integer, sequence based (bioperl) position coordinates

  OUTPUT: 
         * sequences whose length falls within at least one BAND in the SPECTRUM are output
         * BOUND specification is always inclusive of the bound.

  Examples: fasfilter 1..400       < in.fas > out.fas ## all sequences of length 400 or less
            fasfilter 400..800     < in.fas > out.fas ## all sequences of length between 400 and 800 inclusively
            fasfilter 800..        < in.fas > out.fas ## all sequences of length 800 or more
            fasfilter 1..400,800.. < in.fas > out.fas ## all sequences of length 400 or less or 800 or more

            
   Options: -h print this help
           -f <format> read <format> on input instead of default fasta.
               <format> may be one of: embl,exp,fastq,gcg,genbank,pir,scf
                                       ace,game,locuslink,phd,qual,raw,swiss    
QQ_HELP_QQ
exit 1;
}

##PARSE MULTICOORDS
if ($ARGV[0] =~ /,/) {
    @BANDS = split /,/,$ARGV[0];
  }
else {
  $BANDS[0] = $ARGV[0];
}

$IN = FAST::Bio::SeqIO->new(-fh => *STDIN{IO}, '-format' => $opt_f);
$OUT = FAST::Bio::SeqIO->newFh('-format' => $opt_f);
sequence: while (my $seq = $IN->next_seq()) {
    my $seqlen = $seq->length;
    my $pass   = undef;
    foreach my $band (@BANDS) {
      my ($b,$e,$l);
      if ($band =~ /([\d-]+)\.\.([\d-]+)/) {
	$b = $1;
	$e = $2;	
	$pass = 1 if ($b <= $seqlen && $e >= $seqlen);
      }
      elsif ($band =~ /([\d-]+)\.\./) {
	$l = $1;	
	$pass = 1 if ($l <= $seqlen);
      }
      else {
	die "Bad band specification $band.\nTry $0 -h\n";
      }
    }
    print $OUT $seq if ($pass);
}















